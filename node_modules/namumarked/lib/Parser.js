/**
 * NamuMarked Parser
 * Copyright RedPumpkin.
 * 
 * MIT Licensed.
 */
'use strict';

const utils = require('./utils');

const default_option = {
	renderer: null
};

class Parser {
	constructor(opt) {
		this.options = utils.extend(default_option, opt);
	}

	parse(tokens, renderer) {
		if (!Array.isArray(tokens) || tokens.length <= 0) {
			return '';
		}

		let item = tokens[0];
		let buff = '';
		let l = tokens.length;

		// 리다이렉트면 파싱 건너 뜀
		if (item.type === 'redirect') {
			return renderer.redirect(item.goto);
		}

		let i = 0;

		let block = function block(tag) {
			let item;
			let c = [];
			let depth = 0;

			let l = tokens.length;
			for (i++; i < l; i++) {
				item = tokens[i];

				if (item.type === tag + '_start') {
					depth++;
					c.push(item);
				} else if (item.type === tag + '_end') {
					if (depth > 0) {
						depth--;
						c.push(item);
					} else {
						break;
					}
				} else {
					c.push(item);
				}
			}

			if (i === l) {
				throw new Error('expected ' + tag + '_end');
			}

			// 앞에서 i 땡겨썼으니까.
			i--;

			return this.parse(c, renderer);
		}

		for (; i < l; i++) {
			item = tokens[i];

			switch (item.type) {
				case 'newline':
					buff += renderer.newline();
					break;

				case 'math':
					buff += renderer.math(item.content);
					break;

				case 'extimg':
				 	buff += renderer.extimg(item.src, item.options);
					break;
				
				case 'heading':
				 	buff += renderer.heading(item.depth, item.text);
					break;

				case 'hr':
					buff += renderer.hr();
					break;

				case 'blockquote_start':
					buff += renderer.blockquote(block.call(this, 'blockquote'));
					break;

				case 'unordered_list_start':
					buff += renderer.list(block.call(this, 'unordered_list'), false);
					break;

				case 'ordered_list_start':
					buff += renderer.list(block.call(this, 'ordered_list'), true);
					break;

				case 'list_item_start':
					buff += renderer.list_item(block.call(this, 'list_item'));
					break;

				case 'table_start':
					buff += renderer.table(block.call(this, 'table'), item.options);
					break;

				case 'table_caption':
					buff += renderer.table_caption(item.content);
					break;

				case 'table_row_start':
					buff += renderer.table_row(block.call(this, 'table_row'), item.options);
					break;

				case 'table_cell_start':
					buff += renderer.table_cell(block.call(this, 'table_cell'), item.options);
					break;

				case 'textbox_start':
					buff += renderer.textbox(block.call(this, 'textbox'));
					break;

				case 'paragraph':
					buff += renderer.paragraph(item.text);
					break;
				
				case 'text':
					buff += renderer.text(item.text);
					break;
			}
		}
		
		return buff;
	}
}

Parser.parse = function (tokens, opt) {
	let parser = new Parser(opt);
	return parser.parse(tokens);
}

module.exports = Parser;