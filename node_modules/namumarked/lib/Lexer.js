/**
 * NamuMarked Lexer
 * Copyright (c) Redpumpkin
 * 
 * Licensed under the MIT license.
 */
'use strict';

const utils = require('./utils');

const default_option = {
	'image_ext': ['jpg', 'jpeg', 'png', 'gif']
};

/**
 * Lexer class
 */
class Lexer {
	constructor(opt) {
		this.tokens = [];
		this.tokens.links = {};
		this.options = utils.extend(default_option, opt);

		this.rules = {
			redirect: /^#(?:redirect|넘겨주기) (.+)/,

			paragraph: /^((?:[^\n]+\n?(?!hr|indent|heading|textbox|extimg|blockquote|list|table))+)\n*/,
			hr: /^ *-{3,10} *(?:\n+|$)/,
			indent: /^ [^\n]+(?:\n [^\n]*)*/,
			newline: /^\n+/,
			heading: /^ *(={1,6}) +([^\n]+?) +\1 *(?:\n+|$)/,
			space: /^ /gm,
			text: /^[^\n]+/,
			textbox: /^{{\|((?:.|\n)+?)\|}}/,
			math: /<math>((?:.|\n)+?)<\/math>/,

			extimg: /^(https?:\/\/([^\n])+)(\.(?:<ext>))(\?.+)?(?:\n+|$)/,
			extimg_options: /(?:^\?|&)([^&=]+)=([^&]+)/g,

			blockquote: /^> ?[^\n]*(?:\n *> *[^\n]*)*/,
			blockquote_bullets: /^ *> ?/gm,

			list: /^ (?:([1iIaA])\.(?:#([0-9]+))?|\*)[^\n]*(?:\n +[^\n]*)*/,
			list_bullets: /^ ([1iIaA]\.(?:#[0-9]+)?|\*) ?/,
			list_item: /^ (?:[1iIaA]\.|\*)[^\n]*(?:\n (?![1iIaA]\.|\*)[^\n]*)*/gm,
			list_ordered_bullets: /^ ([1iIaA])\.(?:#([0-9]+))?/,
			list_unordered_bullets: /^ \*/,
			
			table: /^<table_row>(?:<table_row>)*/,
			table_caption: /(?:\|{2}|\|([^\n\|]+?)\|)/,
			table_row: /^\n?(<table_cell>(?:<table_cell>)*)\|{2}/,
			table_cell: /^\|{2}(?:\|{2})*(?!\n)(?:(?!\|{2}|\n{2})[\s\S])*/,
			table_content: /^(?:((?:\|{2})+)|<(?:(?:(table) ?|(row))?([^>=]+)=([^>=]+)|([\(:)])|(-|[\^v]?\|)([1-9][0-9]*))>|( )?([\s\S]+?)( )?$)/,
		};

		this.rules.extimg = utils.replace(this.rules.extimg)
			(/<ext>/gi, this.options.image_ext.join('|'))
			();

		this.rules.table_row = utils.replace(this.rules.table_row)
			(/<table_cell>/gi, this.rules.table_cell)
			();

		this.rules.table = utils.replace(this.rules.table)
			(/<table_row>/gi, this.rules.table_row)
			(/\\\|\{2}/, this.rules.table_caption)
			();

		this.rules.paragraph = utils.replace(this.rules.paragraph)
			('hr', this.rules.hr)
			('indent', this.rules.indent)
			('heading', this.rules.heading)
			('\\1', '\\2')
			('textbox', this.rules.textbox)
			('math', this.rules.math)
			('extimg', this.rules.extimg)
			('blockquote', this.rules.blockquote)
			('list', this.rules.list)
			('table', this.rules.table)
			();
	}

	/**
	 * Lexing
	 */
	lex(src) {
		return this.token(src, true);
	}

	token(src, top) {
		src = src.replace(/^ +$/gm, '');

		// Generial
		let cap;
		let nc;
		let options;
		let item;
			
		// Loop
		let i;
		let j;
		let il;
		let jl;

		// List
		let start;
		let bull;
		let unordered;

		// Table
		let table;
		let row;
		let cell;
		let cc;

		if (cap = this.rules.redirect.exec(src)) {
			return [{
				type: 'redirect',
				goto: cap[1]
			}];
		}

		while (src) {
			// newline
			if (cap = this.rules.newline.exec(src)) {
				src = src.substring(cap[0].length);
				this.tokens.push({
					type: 'newline'
				});
			}

			// extimg
			if (cap = this.rules.extimg.exec(src)) {
				src = src.substring(cap[0].length);
				options = {};

				// ~~.ext
				if (cap[2] !== '?') {
					cap[1] += cap.slice(3).join('');
				} else {
					cap[1] = cap[1].replace(/\?$/, '');
				}

				if (cap[4] !== undefined) {
					while (true) {
						nc = this.rules.extimg_options.exec(cap[4]);
						if (nc === null) {
							break;
						}

						options[nc[1]] = nc[2];
					}
				}

				this.tokens.push({
					type: 'extimg',
					src: cap[1],
					options: options,
				});
				continue;
			}

			// heading
			if (cap = this.rules.heading.exec(src)) {
				src = src.substring(cap[0].length);								
				this.tokens.push({
					type: 'heading',
					depth: cap[1].length,
					text: cap[2],
				});
				continue;
			}

			// hr
			if (cap = this.rules.hr.exec(src)) {
				src = src.substring(cap[0].length);
				this.tokens.push({
					type: 'hr'
				});
				continue;
			}

			// blockquote
			if (cap = this.rules.blockquote.exec(src)) {
				src = src.substring(cap[0].length);

				this.tokens.push({
					type: 'blockquote_start'
				});

				// blockquote 한 단계식 제거
				cap = cap[0].replace(this.rules.blockquote_bullets, '');

				// 내용 파싱
				this.token(cap, top, true);

				this.tokens.push({
					type: 'blockquote_end'
				});

				continue;
			}

			// list
			if (cap = this.rules.list.exec(src)) {
				src = src.substring(cap[0].length);

				// if unordered list
				if (cap[1] === undefined) {
					bull = '*';
					this.tokens.push({
						type: 'unordered_list_start',
					});
				} else {
					nc = this.rules.list_ordered_bullets.exec(cap[0]);
					
					bull = nc[1];
					start = Number(nc[2]);
					start = Number.isInteger(start)
						? start
						: 1;

					this.tokens.push({
						type: 'ordered_list_start',
						bullets: bull,
						start: start
					});
				}

				// 최상위 아이템들 기준으로 나눔
				cap = cap[0].match(this.rules.list_item);

				i = 0;

				il = cap.length;
				for (; i < il; i++) {
					item = cap[i];
					unordered = this.rules.list_unordered_bullets.test(item);

					// if ordered -> unordered
					if (bull !== '*' && unordered) {
						this.tokens.push({
							type: 'ordered_list_end'
						});
						this.tokens.push({
							type: 'unordered_list_start'
						});
						bull = '*';
					} else if (!unordered) {
						nc = this.rules.list_ordered_bullets.exec(item);

						start = Number(nc[2]);
						start = Number.isInteger(start)
							? start
							: 1;

						// if unordered -> ordered
						if (bull === '*') {
							bull = nc[1];

							this.tokens.push({
								type: 'unordered_list_end'
							});
							this.tokens.push({
								type: 'ordered_list_start',
								bullets: bull,
								start: start
							});
						}
						// if ordered -> ordered
						else if (bull != undefined && bull != nc[1]) {
							bull = nc[1];

							this.tokens.push({
								type: 'ordered_list_end'
							});
							this.tokens.push({
								type: 'ordered_list_start',
								bullets: bull,
								start: start
							});
						}
					}

					item = item
						// 리스트 번호 제거
						.replace(this.rules.list_bullets, '')
						// 맨 앞 공백 제거
						.replace(this.rules.space, '');

					this.tokens.push({
						type: 'list_item_start'
					});

					// 내용 파싱
					this.token(item, false);

					this.tokens.push({
						type: 'list_item_end'
					});
				}

				this.tokens.push({
					type: unordered
						? 'unordered_list_end'
						: 'ordered_list_end'
				});

				continue;
			}

			// table
			if (cap = this.rules.table.exec(src)) {
				src = src.substring(cap[0].length);

				table = {
					options: {},
					caption: null,
					rows: []
				}

				// caption
				nc = this.rules.table_caption.exec(cap[0]);
				if (nc[1]) {
					cap[0] = '||' + cap[0].substring(nc[0].length);
					table.caption = nc[1];
				}

				while (nc = this.rules.table_row.exec(cap[0])) {
					cap[0] = cap[0].substring(nc[0].length);

					row = {
						options: {},
						cols: []
					}

					while (cc = this.rules.table_cell.exec(nc[1])) {
						nc[1] = nc[1].substring(cc[0].length);

						cell = {
							options: {},
							content: ''
						}

						while (item = this.rules.table_content.exec(cc[0])) {
							if (item[1]) {
								cell.options.colspan = Math.floor(item[1].length / 2);
							} else if (item[4]) {
								if (item[2]) { // 테이블 옵션? 
									// 이미 그 옵션 있음
									if (table.options.hasOwnProperty(item[4])) {
										cell.content = cc[0];
										break;
									} else {
										table.options[item[4]] = item[5];
									}
								} else if (item[3]) { // row 옵션?
									if (row.options.hasOwnProperty(item[4])) {
										cell.content = cc[0];
										break;
									} else {
										row.options[item[4]] = item[5];
									}
								} else { // cell 옵션?
									if (cell.options.hasOwnProperty(item[4])) {
										cell.content = cc[0];
										break;
									} else {
										cell.options[item[4]] = item[5];
									}
								}
							} else if (item[6]) { // 정렬?
								switch (item[6]) {
									case '(':
										cell.options.align = 'left';
										break;
										
									case ':':
										cell.options.align = 'center';
										break;
										
									case ')':
										cell.options.align = 'right';
										break;
								}
							} else if (item[7]) { // colspan, rowspan, vertical align
								switch (item[7]) {
									case '-':
										cell.options.colspan = Number.parseInt(item[8]);
										break;

									case '|':
										cell.options.rowspan = Number.parseInt(item[8]);

									case '^|':
										cell.options.rowspan = Number.parseInt(item[8]);
										cell.options.valign = 'top';

									case 'v|':
										cell.options.rowspan = Number.parseInt(item[8]);
										cell.options.valign = 'bottom';
								
									default:
										break;
								}
							} else if (item[10]) { // content
								if (item[9] && item[11]) {
									cell.options.align = 'center';
								} else if (item[9]) {
									cell.options.align = 'left';
								} else if (item[11]) {
									cell.options.align = 'right';
								}

								cell.content = item[10];
								break;
							}

							cc[0] = cc[0].substring(item[0].length);
						}
						
						row.cols.push(cell);
					}

					table.rows.push(row);
				}

				this.tokens.push({
					type: 'table_start',
					options: {
						align: table.options['align'] ? table.options['align'] : null,
						bgcolor: table.options['bgcolor'] ? table.options['bgcolor'] : null,
						bordercolor: table.options['bordercolor'] ? table.options['bordercolor'] : null,
						width: table.options['width'] ? table.options['width'] : null
					}
				});

				if (table.caption) {
					this.tokens.push({
						type: 'table_caption',
						content: table.caption
					});
				}

				i = 0;
				il = table.rows.length;
				for (; i < il; i++) {
					row = table.rows[i];

					this.tokens.push({
						type: 'table_row_start',
						options: {
							bgcolor: row.options['bgcolor'] ? row.options['bgcolor'] : null
						}
					});

					j = 0;
					jl = row.cols.length;
					for (; j < jl; j++) {
						cell = row.cols[j];

						this.tokens.push({
							type: 'table_cell_start',
							options: {
								colspan: cell.options['colspan'] ? cell.options['colspan'] : 1,
								rowspan: cell.options['rowspan'] ? cell.options['rowspan'] : 1,
								bgcolor: cell.options['bgcolor'] ? cell.options['bgcolor'] : null,
								width: cell.options['width'] ? cell.options['width'] : null,
								height: cell.options['height'] ? cell.options['height'] : null,
								align: cell.options['align'] ? cell.options['align'] : null,
								valign: cell.options['valign'] ? cell.options['valign'] : null,
							}
						});

						this.token(cell.content, false);

						this.tokens.push({
							type: 'table_cell_end'
						});
					}

					this.tokens.push({
						type: 'table_row_end'
					});
				}

				this.tokens.push({
					type: 'table_end'
				});

				continue;
			}

			// indent
			if (cap = this.rules.indent.exec(src)) {
				src = src.substring(cap[0].length);

				this.tokens.push({
					type: 'indent_start'
				});

				cap = cap[0].replace(this.rules.space, '');

				this.token(cap, true);

				this.tokens.push({
					type: 'indent_end'
				});

				continue;
			}

			// textbox
			if (cap = this.rules.textbox.exec(src)) {
				src = src.substring(cap[0].length);

				this.tokens.push({
					type: 'textbox_start'
				});

				this.token(cap[1], true);

				this.tokens.push({
					type: 'textbox_end'
				});

				continue;
			}

			// math
			if (cap = this.rules.math.exec(src)) {
				src = src.substring(cap[0].length);

				this.tokens.push({
					type: 'math',
					content: cap[1]
				});

				continue;
			}

			// 최상위 문단
			if (top && (cap = this.rules.paragraph.exec(src))) {
				src = src.substring(cap[0].length);
				cap[1] = cap[1].replace(/^[\n\s]+|[\n\s]+$/g, '');

				this.tokens.push({
					type: 'paragraph',
					text: cap[1]
				});
				continue;
			}

			// text
			if (cap = this.rules.text.exec(src)) {
				// 최상위 요소는 절대 올 일 없음.
				src = src.substring(cap[0].length);
				cap[0] = cap[0].replace(/^[\n\s]+|[\n\s]+$/g, '');

				this.tokens.push({
					type: 'text',
					text: cap[0]
				});
				continue;
			}

			if (src) {
				throw new Error('Infinite loop on byte: ' + src.charCodeAt(0) + ', src: ' + src);
			}
		}

		return this.tokens;
	}
}

Lexer.lex = function(src, opt) {
	let lexer = new Lexer(opt);
	return lexer.lex(src);
}

module.exports = Lexer;