/**
 * NamuMarked InlineLexer
 * Copyright (c) Redpumpkin
 * 
 * Licensed under the MIT license.
 */
'use strict';

const utils = require('./utils');

const default_option = {
	// 문서가 존재하는지 확인하고 있을 경우 true를 리턴.
	// 렉싱중에 확인할 방법은 없으므로 그냥 true.
	link_callback: () => { return true; }
};

/**
 * Inline lexer class
 */
class InlineLexer {
	constructor(opt) {
		this.options = utils.opt(default_option, opt || {});

		this.rules = {
			strong: /^'{3}((?:(?!'{2})[^\n])+)?/,
			italic: /^'{2}((?:(?!'{2})[^\n])+)?/,
			delete: /^~{2}([^\n]+?)~{2}/,
			delete_alt: /^-{2}([^\n]+?)-{2}/,
			underline: /^_{2}([^\n]+?)_{2}/,
			superscript: /^\^{2}([^\n]+?)\^{2}/,
			subscript: /^,{2}([^\n]+?),{2}/,
			text: /^(?:[^\n]|\n)+?(?=<strong>|<italic>|<underline>|<superscript>|<subscript>|$)/,
		}

		this.rules.text = utils.replace(this.rules.text)
			(/<strong>/gi, this.rules.strong)
			(/<italic>/gi, this.rules.italic)
			(/<delete>/gi, this.rules.delete)
			(/<underline>/gi, this.rules.underline)
			(/<superscript>/gi, this.rules.superscript)
			(/<subscript>/gi, this.rules.subscript)
			();
	}

	/**
	 * Run!
	 */
	lex(tokens, renderer) {
		this._renderer = renderer;

		let i = 0;
		let l = tokens.length;
		for (; i < l; i++) {
			// 인라인 렉싱은 텍스트에만...
			if (tokens[i].type === 'text' || tokens[i].type === 'paragraph') {
				tokens[i].text = this.output(tokens[i].text);
			}
		}

		return tokens;
	}

	/**
	 * Lexing
	 */
	output(src) {
		src = src.replace(/^ +$/gm, '');

		// Generial
		let cap;
		let out = '';
		let stack = [];
		// [
		//     'strong',
		//     'italic',
		// ]

		while (src) {
			// strong
			if (cap = this.rules.strong.exec(src)) {
				if (stack[stack.length - 1] === 'strong') {
					src = src.substring(cap[0].length);

					// 스택 하나 뺌.
					stack.pop();

					// 닫는 태그
					out += this._renderer.strong();
					if (cap[1]) {
						out += this.output(cap[1]);
					}

					continue;
				} else if (!~stack.indexOf('strong') && (cap[1] || src.startsWith("'''''"))) {
					src = src.substring(cap[0].length);

					// 스택 추가
					stack.push('strong');

					// 여는 태그 + 컨텐츠
					out += this._renderer.strong(cap[1] ? this.output(cap[1]) : '');
					
					continue;
				}
			}

			// italic
			if (cap = this.rules.italic.exec(src)) {
				if (stack[stack.length - 1] === 'italic') {
					src = src.substring(cap[0].length);

					// 스택 하나 뺌.
					stack.pop();

					// 닫는 태그
					out += this._renderer.italic();
					if (cap[1]) {
						out += this.output(cap[1]);
					}

					continue;
				} else if (!~stack.indexOf('italic') && (cap[1] || src.startsWith("'''''"))) {
					src = src.substring(cap[0].length);
					
					// 스택 추가
					stack.push('italic');

					// 여는 태그 + 컨텐츠
					out += this._renderer.italic(cap[1] ? this.output(cap[1]) : '');

					continue;
				}
			}

			// delete
			if (cap = this.rules.delete.exec(src)) {
				src = src.substring(cap[0].length);
				out += this._renderer.delete(this.output(cap[1]));
				continue;
			}

			// delete_alt
			if (cap = this.rules.delete_alt.exec(src)) {
				src = src.substring(cap[0].length);
				out += this._renderer.delete(this.output(cap[1]));
				continue;
			}

			// underline
			if (cap = this.rules.underline.exec(src)) {
				src = src.substring(cap[0].length);
				out += this._renderer.underline(this.output(cap[1]));
				continue;
			}

			// superscript
			if (cap = this.rules.superscript.exec(src)) {
				src = src.substring(cap[0].length);
				out += this._renderer.superscript(this.output(cap[1]));
				continue;
			}

			// subscript
			if (cap = this.rules.subscript.exec(src)) {
				src = src.substring(cap[0].length);
				out += this._renderer.subscript(this.output(cap[1]));
				continue;
			}

			// text
			if (cap = this.rules.text.exec(src)) {
				src = src.substring(cap[0].length);
				out += cap[0];
				continue;
			}

			if (src) {
				throw new Error('Infinite loop on byte: ' + src.charCodeAt(0));
			}
		}

		return out;
	}
}

/**
 * Static methods
 */
InlineLexer.lex = function(src, options) {
	let lexer = new InlineLexer(options);
	return lexer.lex(src);
}

InlineLexer.getDefaultOptions = function() {
	return default_option;
}

module.exports = InlineLexer;