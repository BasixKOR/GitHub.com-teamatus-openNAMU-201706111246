/**
 * NamuMarked Tester
 * Copyright RedPumpkin.
 * 
 * MIT Licensed.
 */
'use strict';

const fs = require('fs');
const path = require('path');
const namumarked = require('../');
const should = require('should');

class Tester {
	constructor() {
		this.dir = __dirname + '/tests';
		this.ext = 'namu';

		console.log('Test starts at ' + Date());

		console.log('\nLexer rules:');
		console.log(new namumarked.Lexer().rules);

		console.log('\nInline lexer rules:');
		console.log(new namumarked.InlineLexer().rules);
	}

	load() {
		let file;
		let files = [];
		let i;

		let list = fs.readdirSync(this.dir).filter((file) => {
			return path.extname(file) === '.' + this.ext;
		});

		for (i in list) {
			file = path.join(this.dir, list[i]);
			files[path.basename(file, '.namu')] = {
				namu: fs.readFileSync(file, 'utf-8'),
				html: fs.readFileSync(file.replace(new RegExp('\\.' + this.ext + '$'), '.html'), 'utf-8')
			};
		}

		return files;
	}

	run() {
		let tests = this.load();
		let file;

		describe('Namumarked', () => {
			for (file in tests) {
				// Test Scope
				(function(namumarked, file, test) {
					it(this.displayName(file), () => {
						namumarked.text(test.namu).should.equal(test.html);
					});
				}).call(this, new namumarked.NamuMarked(), file, tests[file]);
			}
		});
	}

	displayName(name) {
		return name
				.replace('_', ' ')
				.replace(/([a-z])([A-Z])/, '$1 $2')
				.replace(/^([a-z])/, (m, p1, p2) => { return p1.toUpperCase() })
				.trim();
	}
}

new Tester().run();